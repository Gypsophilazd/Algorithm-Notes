`rating = 1700`
## 题目描述

凯撒大帝喜欢让他的士兵列队。假设他的军队有 $n_1$ 个步兵和 $n_2$ 个骑兵。他认为超过 $k_1$ 个步兵连续排列或是超过 $k_2$ 个骑兵连续排列是不优雅的。请找出共有多少种优雅的列队方案数。

注：所有 $n_1+n_2$ 个士兵都要被排列，且所有步兵和骑兵都视作相同。

## 输入格式

一行包含四个空格隔开的正整数 $n_1,n_2,k_1,k_2(1 \leq n_1, n_2 \leq 100, 1 \leq k_1, k_2 \leq 10)$，分别代表步兵的数量、骑兵的数量、最大的连续步兵数量和最大的连续骑兵数量。

## 输出格式

输出优雅的列队方案数，结果对 $100000000(10^8)$ 取模

## 输入输出样例 #1

### 输入 #1

```
2 1 1 10

```

### 输出 #1

```
1

```

## 输入输出样例 #2

### 输入 #2

```
2 3 1 2

```

### 输出 #2

```
5

```

## 输入输出样例 #3

### 输入 #3

```
2 4 1 1

```

### 输出 #3

```
0

```

## 说明/提示

$1$ 表示步兵，$2$ 表示骑兵。

第一个样例中，只有一种优雅的排列方式：$121$。

第二个样例中，有五种优雅的排列方式：$12122,12212,21212,21221,22121$。

## Solution

显然考虑计数 DP。资源有限 -> 需要知道用了几个步兵/骑兵。

考虑设计状态 `dp[i][j][k][p]` 为用了 $i$ 个步兵， $j$ 个骑兵，结尾 $k = 0/1$ 分别表示队列结尾为步兵/骑兵，当前连续了 $p$ 个同样兵种时的方案数。

状态较多，考虑分类讨论。分为步兵/骑兵，保持状态/转换状态来思考。
大循环必为：
	① 初始化 `dp[1][0][0][1] = dp[0][1][1][1] = 1;`
	② 考虑步兵状态转移方程的推导，一个比较清晰的做法是根据以上所谓”保持当前状态与进行转换“。
		（1）即当 $k = 0$ 结尾是步兵，$p=1$ 时，表示当前最后一个是步兵，也就是说上一步的状态必然是骑兵，就可以考虑把所有骑兵的状态相加，即来自不同状态进行统计。
		（2）当 $k = 0, p > 1$ 时，表示当前最后一个是步兵，上一个也是步兵，这个时候方案需要继承，即一个类似平行宇宙的思路，这里也是最难理解的一步，就是假设已经有 $x$ 种方案，在这 $x$ 种后都加上一个步兵，那么总的方案仍然是 $x$ 种。
	③ 同理对偶的考虑骑兵的状态转移方程，那么总的状态转移方程为：
	$$\left\{\begin{matrix}dp[i][j][0][p]=\sum_{1}^{k_2}{dp[i-1][j][1][p]}\space \space p=1
 \\dp[i][j][0][p] = dp[i-1][j][0][p] \space \space p>1
 \\dp[i][j][1][p] = \sum_{1}^{k_1}{dp[i][j-1][0][p]}\space \space p=1
 \\dp[i][j][1][p] = dp[i][j-1][1][p] \space \space p>1
\end{matrix}\right.$$

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 105;
const int mod = 1e8;
int dp[N][N][2][11]; //dp[i][j][k][p] have used i footmen, j horsemen, end-> k=0 footmen, k=1 horsemen, p-consecutiveness

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n1, n2, k1, k2; cin >> n1 >> n2 >> k1 >> k2;
    for(int i = 0; i <= n1; ++i){
        for(int j = 0; j <= n2; ++j){
            for(int p = 0; p <= 10; ++p) dp[i][j][0][p] = dp[i][j][1][p] = 0;
        }
    }
    dp[1][0][0][1] = dp[0][1][1][1] = 1;
    for(int i = 0; i <= n1; ++i){
        for(int j = 0; j <= n2; ++j){
            if(i > 0){
                for(int k = 1; k <= k1; ++k){
                    if(k == 1){
                        for(int p = 1; p <= k2; ++p) dp[i][j][0][k] = (dp[i][j][0][k] + dp[i - 1][j][1][p]) % mod;
                    }
                    else dp[i][j][0][k] = dp[i - 1][j][0][k - 1];
                }
            }
            if(j > 0){
                for(int k = 1; k <= k2; ++k){
                    if(k == 1){
                        for(int p = 1; p <= k1; ++p) dp[i][j][1][k] = (dp[i][j][1][k] + dp[i][j - 1][0][p]) % mod;
                    }
                    else dp[i][j][1][k] = dp[i][j - 1][1][k - 1];
                }
            }
        }
    } 
    int ans = 0;
    for(int p = 1; p <= k1; ++p) ans = (ans + dp[n1][n2][0][p]) % mod;
    for(int p = 1; p <= k2; ++p) ans = (ans + dp[n1][n2][1][p]) % mod;
    cout << ans << endl;
    return 0;
}
```