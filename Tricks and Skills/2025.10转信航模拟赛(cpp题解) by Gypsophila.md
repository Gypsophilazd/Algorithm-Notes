# U617047 签文故障

## 题目背景

$bot$ 的签文有问题喵。

## 题目描述

$bot$ 给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出 $no$。

## 输入格式

一个字符串，长度小于 $100000$ 。

## 输出格式

输出第一个仅出现一次的字符，若没有则输出 $no$ 。

## 输入输出样例 #1

### 输入 #1

```
abcabd
```

### 输出 #1

```
c
```

## 输入输出样例 #2

### 输入 #2

```
aabbcc
```

### 输出 #2

```
no
```

## Solution

考虑最淳朴的暴力遍历，对于输入的字符串，利用 `cpp` 便捷的 `string` 进行遍历，开一个“桶”，即一个计数数组 `cnt[x]` 表示字母 $x$ 出现的次数，再根据题目条件判断即可。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int cnt[30];

signed main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	string s; cin >> s;
    for(const auto& ch : s) cnt[ch - 'a']++;
    bool flag = 0;
    char ans;
    for(const auto& ch : s){
        if(cnt[ch - 'a'] == 1){
            flag = 1, ans = ch;
            break;
        }
    }
    if(!flag) cout << "no" << '\n';
    else cout << ans << '\n';
	return 0;
}
```

# U621287 乌拉姆数列

## 题目描述

乌拉姆数列是由波兰数学家乌拉姆提出的一种特殊数列，构造规则如下：
 
1. 从两个互质的正整数 $a$ , $b$ 开始（通常取 $1$ 和 $2$）

2. 下一个数是所有`可以唯一表示为数列中两个不同数之和的数`中的最小数

3. 重复步骤 $2$ 扩展数列
 
例如，从 $1$, $2$ 开始的乌拉姆数列前几项是：
$1, 2, 3, 4, 6, 8, 11, 13, 16, 18, 26, ...$

1. 初始数列：$[1, 2]$

2. 可能的和：$1+2=3$ → 唯一出现的和是 $3$ ，加入数列 → $[1, 2, 3]$

3. 新的可能和：$1+3=4$，$2+3=5$ → 最小唯一和是$4$ → $[1, 2, 3, 4]$

4. 继续计算：1+4=5，2+4=6，3+4=7 → 唯一出现的和是6和7，因为 $5$ 可以是 $2+3$ 也可以是 $1+4$ ，取最小的 $6$ → $[1, 2, 3, 4, 6]$

现输入两个起始数 $a$, $b$（确保互质），求这个乌拉姆数列的第 $n$ 项。

## 输入格式

共一行，三个空格隔开的正整数 $a$, $b$, $n$。

## 输出格式

一个整数，表示第 $n$ 项。

## 输入输出样例 #1

### 输入 #1

```
1 2 7
```

### 输出 #1

```
11
```

## 说明/提示

$0$ $<$ $a$, $b$, $n$ $<$ $100$，且保证 $a$, $b$ 互质。

## Solution

给定了前两项，按照题目进行模拟即可。这一题也可以按照上一题的方法开"桶"，即计数数组，这里介绍一个 `cpp` 中常用的容器，即也可以使用 `STL` 中的 `map` 记录数列中某个数的出现次数，以判断题目条件中的"唯一"性质。随后根据题给条件 $O(n^2)$ 遍历即可。

### Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 5;
int num[N];

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int a, b, n; cin >> a >> b >> n;
    num[1] = a, num[2] = b; 
    int len = 2;
    while(len < n){
        map<int, int> cnt; //first表示数，second表示数出现的次数
        for(int i = 1; i <= len; i++){
            for(int j = i + 1; j <= len; j++) cnt[num[i] + num[j]]++;
        }
        int nxt = LLONG_MAX;
        for(auto &p : cnt){
            if(p.second == 1 && p.first > num[len]) nxt = min(nxt, p.first);
        }
        num[++len] = nxt;
    }
    cout << num[n] << "\n";
    return 0;
}
```

# U621214 有效IP地址

## 题目描述

有效 $IP$ 地址 正好由四个整数（每个整数位于 $0$ 到 $255$ 之间组成，且不能含有前导 $0$），整数之间用 ' $.$ ' 分隔。

例如："$0.1.2.201$" 和 "$192.168.1.1$" 是 有效 $IP$ 地址，但是 "$0.011.255.245$"、"$192.168.1.312$" 和 "$192.168@1.1$" 是 无效 $IP$ 地址。

现给出一行由空格隔开的若干个 $IP$ 地址，请按原出现顺序输出其中有效的 $IP$ 地址。

## 输入格式

共一行，由空格隔开的若干个 $IP$ 地址。

## 输出格式

共一行，若干个有效 $IP$ 地址，空格隔开，若无有效的，输出 $None$

## 输入输出样例 #1

### 输入 #1

```
1.0.0 0.0.0.0 1.0.1.2.2 192.168.1.1
```

### 输出 #1

```
0.0.0.0 192.168.1.1
```

## 输入输出样例 #2

### 输入 #2

```
h.e.l.l.o w.o.r.l.d
```

### 输出 #2

```
None
```

## 说明/提示

包含的地址数 $n$ 满足 $0$ $<$ $n$ $<$ $1000$。

## Solution

考察 `io` 功底，当然模拟可以做，不过本题解为 `cpp` 题解，可以使用一些 `cpp` 特有的方式。考虑使用 `stringstream` 对字符串进行分割。写一个 `is_valid` 判断每个给出的 `ip` 地址是否合法，再将其加入答案序列。

特别地，这里给出 `stringstream` 解析。
### stringstream 类
#### 字符串格式化

通过流插入操作符`<<`，可将多种数据类型无缝组合为字符串，避免`sprintf`的缓冲区溢出风险：

```cpp
#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::stringstream ss;
    ss << "Age: " << 25 << ", Name: Alice";
    std::cout << ss.str() << std::endl;  // 输出: Age: 25, Name: Alice
    return 0;
}
```
#### 字符串分割

利用`std::getline`按分隔符拆分字符串，替代不安全的`strtok`：

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>

int main() {
    std::string input = "apple,banana,orange";
    std::stringstream ss(input);
    std::string token;
    std::vector<std::string> tokens;

    while (std::getline(ss, token, ',')) {
        tokens.push_back(token);
    }

    for (const auto& t : tokens) {
        std::cout << t << std::endl;  // 依次输出: apple, banana, orange
    }
    return 0;
}
```

#### 类型转换与单向流优化 数据类型转换

支持字符串与数值类型的双向转换，替代`atoi`/`itoa`等C风格函数：

```cpp
#include <iostream>
#include <sstream>
#include <string>

int main() {
    // 字符串转数字
    std::string str = "12345";
    std::stringstream ss(str);
    int num;
    ss >> num;
    std::cout << "Number: " << num << std::endl;  // 输出: Number: 12345

    // 数字转字符串
    std::stringstream ss2;
    ss2 << 3.14;
    std::string pi_str = ss2.str();
    std::cout << "String: " << pi_str << std::endl;  // 输出: String: 3.14
    return 0;
}
```
#### 单向流优化

- **`std::istringstream`**：仅支持读取操作，提升解析效率

```cpp
#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::string input = "100 200 300";
    std::istringstream iss(input);
    int a, b, c;
    iss >> a >> b >> c;
    std::cout << a << ", " << b << ", " << c << std::endl;  // 输出: 100, 200, 300
    return 0;
}
```

- **`std::ostringstream`**：仅支持写入操作，优化构建效率

```cpp
#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::ostringstream oss;
    oss << "Value: " << 42;
    std::cout << oss.str() << std::endl;  // 输出: Value: 42
    return 0;
}
```

## Code 

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<string> split(const string &s){
    vector<string> res;
    stringstream ss(s);
    string p;
    while(getline(ss, p, '.')) res.push_back(p);
    return res;
}
bool is_valid(const string &ip){
    vector<string> p = split(ip);
    if(p.size() != 4) return false;
    for (const string &part : p){
        if(part.empty() || part.size() > 3) return false;
        for(char c : part){
            if (!isdigit(c)) return false;
        }
        if(part.size() > 1 && part[0] == '0') return false;
        int num = stoi(part);
        if(num < 0 || num > 255) return false;
    }
    return true;
}

int main(){
    string line; getline(cin, line);
    stringstream ss(line);
    string ip; vector<string> ans;
    while(ss >> ip){
        if(is_valid(ip)) ans.push_back(ip);
    }
    if(ans.empty()) cout << "None" << endl;
    else{
        for(int i = 0; i < ans.size(); ++i){
            if(i > 0) cout << " ";
            cout << ans[i];
        }
    }
    return 0;
}
```

# U621151 数位排序（二）

## 题目描述

给定一组正整数，请按照以下 `数学规则` 对它们进行排序：

按数字各位数字之和从小到大排序；

若数字之和相同，则按数字的位数从少到多排序；

若仍然相同，则按数字的值从小到大排序。

## 输入格式

第一行一个整数 $n$，接下来 $n$ 行，每一行一个不重复正整数。

## 输出格式

共 $n$ 行，输出排序好的结果。

## 输入输出样例 #1

### 输入 #1

```
6
405
123
39
222
99
303
```

### 输出 #1

```
123
303
222
405
39
99
```

## 说明/提示

对于所有数据：$0$ $<$ $n$ $<$ $1000$，

对于 $80\%$ 数据，正整数 $num$ 满足 $0$ $<$ $num$ $<$ $10000$，

对于 $20\%$数据，正整数 $num$ 满足 $0$ $<$ $num$ $<$ $10^{100}$。

## Solution

考察自定义排序函数的构造。根据题目走需要构建自定义排序规则，按题意一步步构建即可，具体参照代码

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 5;
vector<string> a;

bool cmp(const string& a, const string& b){
    int s1 = 0, b1 = 0, s2 = 0, b2 = 0;
    for(const auto s : a) s1 += (s - '0'), b1++;
    for(const auto s : b) s2 += (s - '0'), b2++;
    if(s1 != s2) return s1 < s2;
    if(b1 != b2) return b1 < b2;
    for(int i = 0; i < a.size(); ++i){
        if(a[i] != b[i]) return a[i] < b[i];
    }
    return 0;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n; cin >> n;
    vector<string> a(n);
    for(int i = 0; i < n; ++i) cin >> a[i];
    sort(a.begin(), a.end(), cmp);
    for(int i = 0; i < n; ++i) cout << a[i] << '\n';
    return 0;
}
```