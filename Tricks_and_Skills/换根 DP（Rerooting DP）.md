
换根 DP，本质上解决的是无根树化有根树时的状态查询问题。它将原本需要 $O(N^2)$ 的暴力枚举根节点过程，通过状态的拆分与重组，优化为 $O(N)$ 的两次 DFS。

## 一、 核心思想

树上相邻的两个节点 $u$（父）和 $v$（子），当整棵树的根从 $u$ 转移到 $v$ 时，整棵树的拓扑结构绝大部分保持不变，**唯一发生相对位置翻转的，只有边 $(u, v)$**。

- **以 $u$ 为根时**：$v$ 及其子树，是 $u$ 的向下贡献。
- **以 $v$ 为根时**：$u$ 以及 $u$ 头顶上的所有部分，变成了 $v$ 的向上贡献（即 $v$ 的一颗新子树）。

## 二、 一般思路

**第一阶段：自底向上 —— `dfs1(u, fa)`**

- **目标**：固定节点 1 为全局根，计算出所有节点在**自身子树内部**的属性（如 $sz[u]$, $dep[u]$, $down\_max[u]$ 等）。
根据题目需求进行前序或者后序遍历。调用 `dfs1(v, u)` 算出儿子的完全体状态，再用儿子的状态更新父亲 $u$，或者进行相反操作。

**第二阶段：自顶向下 —— `dfs2(u, fa)`**

- **目标**：完成状态的乾坤大挪移。父亲 $u$ 将其剥离了 $v$ 之后的剩余状态，作为新的子树状态传递给儿子 $v$。

一般采用前序遍历。父亲 $u$ 必须先算出要塞给 $v$ 的状态（比如 `dp[v]`），然后再调用 `dfs2(v, u)` 让儿子带着这个状态去更新孙子。

## 三、 经典转移模型

**模型 A：累加型 / 求和型（如：树上距离和、连通块求和）**

- **特点**：状态转移满足**可减性**。
- **状态转移方程**：当根从 $u$ 换到 $v$ 时，直接从总状态中**减去** $v$ 子树带来的负面影响，**加上**非 $v$ 子树带来的正面影响。
- _例（距离和）_：$dp[v] = dp[u] - sz[v] + (N - sz[v])$

**模型 B：最值型（如：树上最长链、最大价值分支）**

- **特点**：状态转移**不满足可减性**（无法从最大值中减去一个分支的影响来获得剩余的最大值）。
- **核心维护量**：在 `dfs1` 中，必须对每个节点 $u$ 维护三个变量：
    1. $down1[u]$：向下最大值。
    2. $down2[u]$：向下**次大值**（必须与最大值属于不同的子树分支）。
    3. $mx\_son[u]$：最大值是从哪个儿子转移来的。

- **状态转移方程**：在 `dfs2` 中计算 $v$ 往上的最远距离 `up[v]` 时，必须进行分类讨论（防回头路）：
    
    - 如果 $v == mx\_son[u]$：$v$ 在 $u$ 的最长链上，只能借用次大值 $\implies up[v] = \max(up[u], down2[u]) + weight$。
    - 如果 $v \neq mx\_son[u]$：$v$ 不在最长链上，放心借用最大值 $\implies up[v] = \max(up[u], down1[u]) + weight$。

## 四、例题

Luogu P3478
Luogu P2986
[CF1822F Gardening Friends](CF1822F%20Gardening%20Friends.md)
[CF1324F Maximum White Subtree](CF1324F%20Maximum%20White%20Subtree.md)
[CF1187E Tree Painting](CF1187E%20Tree%20Painting.md)