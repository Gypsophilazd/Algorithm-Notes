`rating = 1600`
## 题目描述

在数轴上有 $n$ 个信标，每个信标的位置互不相同。第 $i$ 个信标位于 $a_i$ 位置，具备能量 $b_i$。当第 $i$ 个信标被激活时，它会摧毁所有在其左侧（坐标更小的方向）距离 $b_i$（含边界）内的信标，但不会摧毁自己。Saitama 将会从右到左依次激活这些信标。如果某个信标已经被摧毁，则不会被激活。

Saitama 希望 Genos 在所有信标的严格右侧增加一个新的信标，位置和能量均可任意选择，使得被摧毁的信标数最少。注意，Genos 增加的新信标将会是第一个被激活的信标。请帮助 Genos 求出在只增加一个信标的情况下，最少能被摧毁的信标数量。

## 输入格式

第一行包含一个整数 $n$（$1 \leq n \leq 100000$），表示初始信标数量。

接下来的 $n$ 行每行包含两个整数 $a_i$ 和 $b_i$（$0 \leq a_i \leq 1000000$，$1 \leq b_i \leq 1000000$），分别表示第 $i$ 个信标的位置和能量。不会有两个信标处于同一位置，即 $a_i \ne a_j$ 当 $i \ne j$ 时。

## 输出格式

输出一个整数，表示在恰好添加一个信标的情况下，最少能被摧毁的信标数量。

## 输入输出样例 #1

### 输入 #1

```
4
1 9
3 1
6 1
7 4

```

### 输出 #1

```
1

```

## 输入输出样例 #2

### 输入 #2

```
7
1 1
2 1
3 1
4 1
5 1
6 1
7 1

```

### 输出 #2

```
3
```

## 说明/提示

对于第一个样例，最少只能摧毁 $1$ 个信标。一种实现方式是在位置 $9$ 处放置能量为 $2$ 的信标。

对于第二个样例，最少会有 $3$ 个信标被摧毁。一种实现方式是在位置 $1337$ 处放置能量为 $42$ 的信标。

由 ChatGPT 5 翻译


## Solution

从数据范围 $1000000$ 可以直接考虑值域 DP。但是这题的状态定义似乎有点 Tricky。
不过细想一下，如果毁灭比较难想，正难则反，可以考虑继承。

`dp[pos]` 表示**在坐标为 `pos` 的地方放最右边的灯塔，最多能保住多少个灯塔**。

在从左往右遍历坐标 `pos` ($0 \to 1000000$) 时，状态转移方程就可以得出了：

1. 如果坐标 `pos` 上**没有**灯塔：那这里放不放无所谓，继承前面的状态就行。
2. 如果坐标 `pos` 上**有**一个威力为 $b$ 的灯塔：它直接摧毁了前面长度为 $b$ 的区域。那么幸存的灯塔数就是“它自己一个”加上“坐标 `pos - b - 1` 的幸存数”。

直接用坐标进行 $O(1)$ 的状态转移，整体复杂度 $O(\max(A))$，也就是 $O(N)$ 级别。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int dis = 1e6 + 5;
int dp[dis], e[dis] = {0};

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n; cin >> n;
    int mx = 0;
    for(int i = 1; i <= n; ++i){
        int x, y; cin >> x >> y;
        e[x] = y;
        mx = max(mx, x);
    }
    if(e[0]) dp[0] = 1;
    for(int i = 1; i <= mx; ++i){
        if(!e[i]) dp[i] = dp[i - 1];
        else{
            if(e[i] + 1 <= i) dp[i] = 1 + dp[i - e[i] - 1];
            else dp[i] = 1;
        }
    }
    int res = 0;
    for(int i = 0; i <= mx; ++i) res = max(res, dp[i]);
    cout << n - res << endl;
    return 0;
}
```

![](Beacon.png)